<?php

namespace Webmasterskaya\TelegramBotCommands\Commands\UserCommands;

use Intervention\Image\ImageManagerStatic as Image;
use Longman\TelegramBot\Commands as BotCommands;
use Longman\TelegramBot\Entities\File;
use Longman\TelegramBot\Entities\InlineKeyboard;
use Longman\TelegramBot\Entities\PhotoSize;
use Longman\TelegramBot\Entities\ServerResponse;
use Longman\TelegramBot\Request;

class AddWatermarkCommand extends BotCommands\UserCommand
{

	/**
	 * @var string
	 */
	protected $name = 'addwatermark';

	/**
	 * @var string
	 */
	protected $description = 'add watermark';

	/**
	 * @var string
	 */
	protected $usage = '/addwatermark';

	/**
	 * @var string
	 */
	protected $version = '1.0.0';

	/**
	 * @var bool
	 */
	protected $private_only = true;

	protected function checkConfig()
	{
		if (empty($this->config['watermark_path']) || !file_exists($this->config['watermark_path']))
		{
			throw new \Exception('Invalid command config! Required parameter `watermark_path` not set or file not exists.');
		}
	}

	public function preExecute(): ServerResponse
	{
		$this->checkConfig();

		return parent::preExecute(); // TODO: Change the autogenerated stub
	}

	public function execute(): ServerResponse
	{
		if ($message = $this->getMessage() ?: $this->getEditedMessage() ?: $this->getChannelPost() ?: $this->getEditedChannelPost())
		{
			if ($photoSizes = $message->getPhoto())
			{
				/** @var PhotoSize $photo */
				$photo = end($photoSizes);

				if ($photo)
				{
					$file_id = $photo->getFileId();

					$file_response = Request::getFile(['file_id' => $file_id]);

					if ($file_response->isOk())
					{
						/** @var File $file */
						$file = $file_response->getResult();

						if (Request::downloadFile($file))
						{
							$download_path  = $this->telegram->getDownloadPath();
							$tg_file_path   = $file->getFilePath();
							$file_path      = realpath($download_path . '/' . $tg_file_path);
							$watermark_path = realpath($this->config['watermark_path']);

							$src       = Image::configure(['driver' => 'Imagick'])->make($file_path);
							$watermark = Image::configure(['driver' => 'Imagick'])->make($watermark_path);

//							$color_picker = Image::make($file_path);
//							$color_picker->resize(1, 1);
//							$base_color = $color_picker->pickColor(0, 0);
//							$contrast   = (($base_color[0] * 299) + ($base_color[1] * 587) + ($base_color[2] * 114)) / 1000;
//
//							if ($contrast <= 128)
//							{
//								$diff = round($contrast * 50 / 128);
//							}
//							else
//							{
//								$diff = round(($contrast - 128) * 50 / 128);
//							}

							$opacity = 25;

//							$this->replyToUser('rgba(' . implode(',', $base_color) . '), Контраст: ' . $contrast . ' Diff: ' . $diff);

							$a     = $src->width(); // Ширина картинки
							$b     = $src->height(); // Высота картинки
							$x     = $watermark->width(); // Исходная ширина вотермарки
							$y     = $watermark->height(); // Исходная высота вотермарки
							$tan   = $b / $a;
							$angle = rad2deg(atan($tan)); // Угол наклона вотермарки относительно горизонтальной оси в градусах

							$c = $b / (sin(deg2rad($angle)) + (cos(deg2rad($angle)) * $y / $x)); // Новая ширина вотермарки
							$d = $c * $y / $x; // Новая высота вотермарки

							$watermark->resize($c, $d, function ($constraint) {
								$constraint->aspectRatio();
								$constraint->upsize();
							});

							$watermark->rotate($angle);

							$watermark->opacity($opacity);

							$src->insert($watermark, 'center');

							$src->save();

							$data = [
								'chat_id'             => $message->getChat()->getId(),
								'photo'               => Request::encodeFile($file_path),
								'caption'             => $message->getCaption(),
								'caption_entities'    => $message->getCaptionEntities(),
								'reply_to_message_id' => $message->getMessageId(),
								'reply_markup'        => new InlineKeyboard(
									[
										[
											'text'          => '-',
											'callback_data' => 'addwatermark_callbackquery_opacity_' . ($opacity - 5)
										],
										[
											'text'          => 'Прозрачность: ' . $opacity,
											'callback_data' => 'do_nothing'
										],
										[
											'text'          => '+',
											'callback_data' => 'addwatermark_callbackquery_opacity_' . ($opacity + 5)
										],
									]
								)
							];

							$send_photo_request = Request::sendPhoto($data);

							if ($send_photo_request->isOk())
							{
								unlink($file_path);
							}
						}
					}
				}
			}
		}

		return Request::EmptyResponse();
	}
}